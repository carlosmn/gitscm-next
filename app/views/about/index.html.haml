- @section = "about"
- @subsection = ""

- content_for :sidebar do
  %div.callout
    %p
      The entire <strong><a href="#">Pro Git book</a></strong> written by Scott Chacon is available to <a href="#">read online for free</a>. Dead tree versions are available on <a href="#">Amazon.com</a>.

%div#main
  %h1 About

  %a{:name => 'cheap-local-branching'}
  %h2 Cheap Local Branching

  %p
    Probably Git's most compelling feature that really makes it stand
    apart from nearly every other SCM out there is its branching
    model.  It is completely different from all of the models I'm 
    comparing it to here, most of which recommend that the best branch
    is basically a clone of the repository in a new directory.

  %p
    %strong= link_to "Read More →", "#", {:class => 'read-more'}


  %div.more
    %p
      Git does not work like that.  Git will allow you to have multiple
      local branches that can be entirely independent of each other and
      the creation, merging and deletion of those lines of development
      take seconds.

    %p
      This means that you can do things like:

    %ul.bullets
      %li
        Create a branch to try out an idea, commit a few times, switch back to where you branched from, apply a patch, switch back to where you are experimenting, then merge it in.
      %li
        Have a branch that always contains only what goes to production, another that you merge work into for testing and several smaller ones for day to day work
      %li
        Create new branches for each new feature you're working on, so you can seamlessly switch back and forth between them, then delete each branch when that feature gets merged into your main line.
      %li
        Create a branch to experiment in, realize it's not going to work and just delete it, abandoning the work—with nobody else ever seeing it (even if you've pushed other branches in the meantime)

    %p
      <img src="/images/about/branches.png" alt="Branches" />

    %p
      Importantly, when you push to a remote repository, you do not have to push all of your branches. You can only share one of your branches and not all of them. This tends to free people to try new ideas without worrying about having to plan how and when they are going to merge it in or share it with others.

    %p
      You can find ways to do some of this with other systems, but the work involved is much more difficult and error-prone. Git makes this process incredibly easy and it changes the way most developers work when they learn it.

  %a{:name => 'everything-is-local'}
  %h2 Everything is Local

  %p
    This is basically true of all the distributed SCMs, but in my experience even more so with Git. There is very little outside of 'fetch', 'pull' and 'push' that communicates in any way with anything other than your hard disk.

  %p
    %strong= link_to "Read More →", "#", {:class => 'read-more'}

  %div.more
    %p
      This not only makes most operations much faster than you may be used to, but it also allows you to work on stuff offline. That may not sound like a big deal, but I'm always amazed at how often I actually do work offline. Being able to branch, merge, commit and browse history of your project while on the plane or train is very productive.

    %p
      <img src="/images/about/local-remote.png" alt="Local / Remote" width="620" />

    %p
      Even in Mercurial, common commands like 'incoming' and 'outgoing' hit the server, whereas with Git you can 'fetch' all the servers data before going offline and do comparisons, merges and logs of data that is on the server but not in your local branches yet.

    %p
      This means that it's very easy to have copies of not only your branches, but also of everyone's branches that are working with you in your Git repository without having to mess your own stuff up.

  %a{:name => 'git-is-fast'}
  %h2 Git is Fast

  %p
    Git is fast. Everyone—even most of the hard core users of these other systems—generally give Git this title. With Git, all operations are performed locally giving it a bit of a leg up on SVN and Perforce, both of which require network access for certain operations. However, even compared to the other DSCMs that also perform operations locally, Git is pretty fast.

  %p
    %strong= link_to "Read More →", "#", {:class => 'read-more'}

  %div.more
    %p
      Part of this is likely because it was built to work on the Linux kernel, which means that it has had to deal effectively with large repositories from day one. Additionally, Git is written in C, reducing the overhead of runtimes associated with higher-level languages. Another reason that Git is so fast is that the primary developers have made this a design goal of the application.

    %p
      The following are a number of benchmarks that I performed on three copies of the Django source code repository in 3 different SCMs: Git, Mercurial and Bazaar. I also tested some of this stuff in SVN, but trust me, it's slower—basically take the Bazaar numbers and then add network latency...

    <table>  
    <tr><td class="nowrap">
    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:2,5,60&amp;chds=0,60&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Init" alt="init benchmarks" />

    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:85,3,23&amp;chds=0,100&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Add" alt="add benchmarks" />

    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:45,194,1474&amp;chds=0,1474&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Status" alt="status benchmarks" />

    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:5,21,142&amp;chds=0,142&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Diff" alt="diff benchmarks" />
    </td><td rowspan="2">
    <img src="http://chart.apis.google.com/chart?cht=bvg&amp;chs=190x275&amp;chd=t:1,123,390|11,946,820&amp;chds=0,1210&amp;chxt=x&amp;chco=4d89f9,c6d9fd&amp;chl=git|hg|bzr&amp;chtt=Branching" alt="branching benchmarks" />
    </td></tr>
    <tr><td class="nowrap">
    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:5,120,189&amp;chds=0,230&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Tag" alt="tag benchmarks" />

    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:7,26,90&amp;chds=0,90&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Log" alt="log benchmarks" />

    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:124,125,230&amp;chds=0,230&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Commit+(Lg)" alt="large commit benchmarks" />

    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:8,51,113&amp;chds=0,113&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Commit+(Sm)" alt="small commit benchmarks" />
    </td></tr>
    </table>

    %p
      The end result was that for everything but adding new files, Git was fastest. (Also really large commits, which Hg was basically the same at, but the commit I tested was so large that you're unlikely to ever do anything like it—normal commits are much faster in Git.)

    <table width="100%" class="data">
    <tr>
    <th></th>
    <th>Git</th>
    <th>Hg</th>
    <th>Bzr</th>
    </tr>
    <tr>
    <th>Init</th>
    <td class="sweet">0.024s</td>
    <td>0.059s</td>
    <td>0.600s</td>
    </tr>
    <tr>
    <th>Add</th>
    <td>8.535s</td>
    <td class="sweet">0.368s</td>
    <td>2.381s</td>
    </tr>
    <tr>
    <th>Status</th>
    <td class="sweet">0.451s</td>
    <td>1.946s</td>
    <td>14.744s</td>
    </tr>
    <tr>
    <th>Diff</th>
    <td class="sweet">0.543s</td>
    <td>2.189s</td>
    <td>14.248s</td>
    </tr>
    <tr>
    <th>Tag</th>
    <td class="sweet">0.056s</td>
    <td>1.201s</td>
    <td>1.892s</td>
    </tr>
    <tr>
    <th>Log</th>
    <td class="sweet">0.711s</td>
    <td>2.650s</td>
    <td>9.055s</td>
    </tr>
    <tr>
    <th>Commit (Large)</th>
    <td class="sweet">12.480s</td>
    <td>12.500s</td>
    <td>23.002s</td>
    </tr>
    <tr>
    <th>Commit (Small)</th>
    <td class="sweet">0.086s</td>
    <td>0.517s</td>
    <td>1.139s</td>
    </tr>
    <tr>
    <th>Branch (Cold)</th>
    <td class="sweet">1.161s</td>
    <td>94.681s</td>
    <td>82.249s</td>
    </tr>
    <tr>
    <th>Branch (Hot)</th>
    <td class="sweet">0.070s</td>
    <td>12.300s</td>
    <td>39.411s</td>
    </tr>
    </table>

    %p
      The cold and hot branching numbers are the numbers for the first and second times that I branched a repo—the second number being a branch with a hot disk cache.

    %p
      It should be noted that although the 'add' numbers are much slower, this was for a massive add operation—over 2000 files. For the majority of what most people do on a daily basis, add ops in any of these systems will only take a fraction of a second. All of the other ops tested here (except for the large commit, possibly) are more indicative of things you might actually do day to day.
    
    %p
      These numbers are really not difficult to recreate, simply clone the Django project in each of the systems and try out the same commands in each.
            

    %code
      git clone git://github.com/brosner/django.git dj-git

    %code
      hg clone http://hg.dpaste.com/django/trunk dj-hg

    %code
      bzr branch lp:django dj-bzr

    %code
      svn checkout http://code.djangoproject.com/svn/django/trunk dj-svn

  %a{:name => 'git-is-small'}
  %h2 Git is Small

  %p
    Git is really good at conserving disk space. Your Git directory will (in general) barely be larger than an SVN checkout—in some cases actually smaller (apparently a lot can go in those .svn dirs).

  %p
    %strong= link_to "Read More →", "#", {:class => 'read-more'}

  %div.more
    %p
      The following numbers were taken from clones of the Django project in each of its semi-official Git mirrors at the same point in its history.

    <table width="100%" class="data">
    <tr>
    <th></th>
    <th>Git</th>
    <th>Hg</th>
    <th>Bzr</th>
    <th>SVN</th>
    </tr>
    <tr>
    <td>Repo Alone</td>
    <td class="sweet">24M</td>
    <td>34M</td>
    <td>45M</td>
    <td></td>
    </tr>
    <tr>
    <td>Entire Directory</td>
    <td class="compare">43M</td>
    <td>53M</td>
    <td>64M</td>
    <td class="compare">61M</td>
    </tr>
    </table>

  %a{:name => 'staging-area'}
  %h2 The Staging Area

  %p
    Unlike the other systems, Git has what it calls the "staging area" or "index". This is an intermediate area that you can setup what you want your commit to look like before you commit it.

  %p
    %strong= link_to "Read More →", "#", {:class => 'read-more'}

  %div.more
    %p
      The cool thing about the staging area, and what sets Git apart from all these other tools, is that you can easily stage some of your files as you finish them and then commit them without committing all the modified files in your working directory, or having to list them on the command line during the commit

    %p
      <img src="/images/about/index1.png" alt="Index 1" />

    %p
      This also allows you to stage only portions of a modified file. Gone are the days of making two logically unrelated modifications to a file before you realized that you forgot to commit one them. Now you can just stage the change you need for the current commit and stage the other change for the next commit. This feature scales up to as many different changes to your file as you need.

    %p
      Of course, Git also makes it pretty easy to ignore this feature if you don't want that kind of control—just slap a '-a' to your commit command in order to add all changes to all files to the staging area.

    %p
      <img src="/images/about/index2.png" alt="Index 2" />

  %a{:name => 'distributed'}
  %h2 Distributed

  %p
    One of the coolest features of any of the Distributed SCMs, Git included, is that it's distributed. This means that instead of doing a "checkout" of the current tip of the source code, you do a "clone" of the entire repository.

  %p
    %strong= link_to "Read More →", "#", {:class => 'read-more'}

  %div.more
    %p
      This means that even if you're using a centralized workflow, every user has what is essentially a full backup of the main server, each of which could be pushed up to replace the main server in the event of a crash or corruption. There is basically no single point of failure with Git unless there is only a single point.

    %p
      This does not slow things down much, either. On average, an SVN checkout is only marginally faster than any of the DSCMs. Of the DSCMs I tested, Git was the fastest.

    <table>
    <tr><td>
    <img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=200x150&amp;chd=t:120,144,311,64&amp;chds=0,320&amp;chco=4d89f9&amp;chl=git|hg|bzr|svn&amp;chtt=Clone" alt="cloning benchmarks" />
    </td><td style="width: 80%">
    <table width="100%" class="data">
    <tr>
    <th>Git</th>
    <td class="sweet">1m 59s</td>
    </tr>
    <tr>
    <th>Hg</th>
    <td>2m 24s</td>
    </tr>
    <tr>
    <th>Bzr</th>
    <td>5m 11s</td>
    </tr>
    <tr>
    <th>SVN</th>
    <td>1m 4s</td>
    </tr>
    </table>
    </td></tr>
    </table>

  %a{:name => 'any-workflow'}
  %h2 Any Workflow

  %p
    One of the amazing things about Git is that because of its distributed nature and super branching system, you can easily implement pretty much any workflow you can think of relatively easily.

  %p
    %strong= link_to "Read More →", "#", {:class => 'read-more'}

  %div.more
    %h3 Subversion-Style Workflow

    %p
      A very common Git workflow, especially from people transitioning from a centralized system, is a centralized workflow. Git will not allow you to push if someone has pushed since the last time you fetched, so a centralized model where all developers push to the same server works just fine.

    %p
      <img src="/images/about/workflow-a.png" alt="Workflow A" />

    %h3 Integration Manager Workflow

    %p
      Another common Git workflow is where there is an integration manager—a single person who commits to the 'blessed' repository, and then a number of developers who clone from that repository, push to their own independent repositories and ask the integrator to pull in their changes. This is the type of development model you often see with open source or GitHub repositories.

    %p
      <img src="/images/about/workflow-b.png" alt="Workflow B" />

    %h3 Dictator and Lieutenants Workflow

    %p
      For more massive projects, you can setup your developers similar to the way the Linux kernel is run, where people are in charge of a specific subsystem of the project ('lieutenants') and merge in all changes that have to do with that subsystem. Then another integrator (the 'dictator') can pull changes from only his/her lieutenants and the push to the 'blessed' repository that everyone then clones from again.

    %p
      <img src="/images/about/workflow-c.png" alt="Workflow C" />
